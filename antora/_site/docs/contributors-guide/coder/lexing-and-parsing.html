<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Lexing and parsing AsciiDoc files :: IntelliJ AsciiDoc Plugin</title>
    <link rel="canonical" href="https://intellij-asciidoc-plugin.ahus1.de/docs/contributors-guide/coder/lexing-and-parsing.html">
    <link rel="prev" href="debugging-and-logging.html">
    <link rel="next" href="inspections.html">
    <meta name="description" content="How to enhance lexing and parsing for AsciiDoc content to improve, for example, syntax highlighting.">
    <meta name="generator" content="Antora 3.1.3">
<!-- https://realfavicongenerator.net/ -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

<link rel="stylesheet" href="../../antora/css/site.css">
<link rel="stylesheet" href="../../antora/css/search.css">
<link rel="stylesheet" href="../../antora/css/custom.css">
<link rel="stylesheet" href="../../antora/css/font-awesome.min.css">
    <script>var uiRootPath = '../../antora'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="/"><img src="/assets/images/ad-logo.svg" height="40" width="40" class="logo" style="margin-right: 0.55rem" alt=""> IntelliJ AsciiDoc Plugin</a>
            <div class="navbar-item search hide-for-print">
                <div id="search-field" class="field has-filter">
                    <input id="search-input" type="text" placeholder="Search the docs">
                        <input checked style="display: none" type="checkbox" data-facet-filter="component:contributors-guide">
                </div>
            </div>
        <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item">
          <a href="/docs/users-guide/quick-start.html">Quick-Start</a>
        </div>
          <div class="navbar-item">
              <a href="/docs/users-guide/index.html">User’s Guide</a>
          </div>
          <div class="navbar-item">
              <a href="/docs/contributors-guide/index.html">Contributor’s Guide</a>
          </div>
        <div class="navbar-item">
          <a href="/docs/users-guide/faq.html">FAQ</a>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="contributors-guide" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Contributor’s Guide</a></h3>
<ul class="nav-list">
  <li class="nav-item is-current-path is-active" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Why contribute</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../contribute-as-a-user.html">Contribute as a user</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../user/write-a-review.html">Write a review</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../user/report-errors.html">Report Errors</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../user/join-discussion-on-github.html">Join the discussion on GitHub</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../user/subscribe-to-new-releases.html">Subscribe to new preview releases</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../user/installing-a-preview-release.html">Installing a preview release</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../user/add-eap-repository-to-ide.html">Using the Early Access repository</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../user/upvote-intellij-issues.html">Upvote IDEA issues</a>
  </li>
</ul>
  </li>
  <li class="nav-item is-current-path is-active" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../contribute-as-a-coder.html">Contribute as a coder</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="setup-environment.html">Setup environment</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="building-and-running.html">Building and running</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="intro-to-plugin-development.html">Plugin development</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="debugging-and-logging.html">Debugging and Logging</a>
  </li>
  <li class="nav-item is-current-page is-active" data-depth="2">
    <a class="nav-link" href="lexing-and-parsing.html">Lexing and parsing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="inspections.html">Inspections</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="preview.html">Rendering preview</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="upgrading-asciidoctor.html">Upgrading Asciidoctor</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="releasing-plugin.html">Releasing the plugin</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../contribute-as-a-writer.html">Contribute as a writer</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../docs/edit-documentation-content.html">Edit documentation content</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../docs/change-documentation-theme.html">Changing the documentation theme</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../docs/change-startpage.html">Changing the start page</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../docs/writing-user-documentation.html">Writing user documentation</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../contribute-as-a-sponsor.html">Contribute as a sponsor</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Contributor’s Guide</span>
    <span class="version">default</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Contributor’s Guide</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">default</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../users-guide/index.html">User’s Guide</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../users-guide/index.html">default</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../users-guide/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Contributor’s Guide</a></li>
    <li><a href="../contribute-as-a-coder.html">Contribute as a coder</a></li>
    <li><a href="lexing-and-parsing.html">Lexing and parsing</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="file:///Users/mac/Repo/aris/antora/doc/contributors-guide/modules/ROOT/pages/coder/lexing-and-parsing.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Lexing and parsing AsciiDoc files</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Lexing and parsing input files is the beginning of both highlighting the code in the editor and building auto-completion and refactoring functionality.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="lexing"><a class="anchor" href="#lexing"></a>Lexing of input files</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Lexing chops the input file into a stream of tokens.
Each token has a type and a snippet of characters.</p>
</div>
<div class="paragraph">
<p>The standard tool in IntelliJ is <a href="https://jflex.de">JFlex</a>.</p>
</div>
<div class="paragraph">
<p>The heart of lexing is <code>asciidoc.flex</code>.
It defines multiple states, and uses a lot of functionalities and tweaking to parse AsciiDoc.
Developers can add new token types in <code>AsciiDocTokenTypes</code>.
Ensure to update the list <code>TOKENS_TO_MERGE</code> if consecutive identical types of the tokens should be merged.
If the content of the token types should be spell-checked, add the token types to the list of tokens in <code>AsciiDocSpellcheckingStrategy</code>.</p>
</div>
<div class="paragraph">
<p>Once the file changed <code>asciidoc.flex</code>, run <code>gradlew compileJava</code> to generate the parser code.</p>
</div>
<div class="paragraph">
<p>A test suite for the lexer is in <code>AsciiDocLexerTest</code>.
I recommend running it from the IDE.
Each test case contains a <code>doTest(...)</code> method that parses one snippet of AsciiDoc and compares it to an expected &#8220;known good&#8221; result.</p>
</div>
<div class="paragraph">
<p>A typical developer workflow for enhancing the lexer looks like this:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Change <code>asciidoc.flex</code> in the IDE, adding new entries to <code>AsciiDocTokenTypes</code> as needed.</p>
</li>
<li>
<p>Run <code>gradlew compileJava</code> on the command line.</p>
</li>
<li>
<p>Add a test case to <code>AsciiDocLexerTest</code> and run it from the IDE.</p>
</li>
<li>
<p>If lexing does not yet work as expected repeat from step 1.</p>
</li>
<li>
<p>If lexing returns the expected result, update the <code>expected</code> parameter in the test.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>There is a ready-to-use run-configuration in Intellij called &#8220;AsciiDocLexerTest&#8221; that will re-generate the lexer and run the tests in one go.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Things to consider when parsing AsciiDoc with JFlex:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JFlex has originally been designed to parse Java code.
AsciiDoc is different.</p>
</li>
<li>
<p>There are no wrong characters in AsciiDoc.
If you get the syntax wrong, the converter usually prints the wrong syntax &#8220;as is&#8221;.
Only a matching set of for example asterisks (<code>*</code>) produces bold text.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here some JFlex rules for AsciiDoc together with an explanation:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Look ahead rules</dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Look ahead rules are considered slow in JFlex, but they give the power to recognize tokens only when there is a matching closing token.</p>
</div>
<div class="paragraph">
<p>A slash (<code>/</code>) separates the matching pattern from the look ahead.</p>
</div>
<div class="listingblock">
<div class="title">Example of parsing typographic quotes</div>
<div class="content">
<pre>{TYPOGRAPHIC_QUOTE_START} / [^\n \t] {WORD}* {TYPOGRAPHIC_QUOTE_END}</pre>
</div>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">End of line and end of file parsing</dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>JFlex supports <code>$</code> to describe the end of a line as look-ahead.
But this doesn&#8217;t work at the end of a file.
To match the end of a file, the lexer uses the fact that JFlex will match the longest rule first (including any look-ahead rules).
So first match the end of a line, then when not at the end of a line with the same length, and then the end of the file (the shortest rule).</p>
</div>
<div class="listingblock">
<div class="title">Example: matching a delimiter at the end of the file</div>
<div class="content">
<pre class="highlight"><code>// delimiter at end of line
{LISTING_BLOCK_DELIMITER} $ { /* ... */ }

// delimiter not at end of line
{LISTING_BLOCK_DELIMITER} / [^\-\n \t] { /* ... */ }

// delimiter at end of file (shorter match than the two above)
{LISTING_BLOCK_DELIMITER} { /* ... */ }</code></pre>
</div>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">Stateful parser</dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To parse bold, italic and monospace text (that can be nested) there is a set of boolean variables to memorize the current text style.
They are reset at the end of a block, like in a regular AsciiDoc file.
The function <code>textFormat()</code> uses them to determine the current token type from a combination of these flags.</p>
</div>
<div class="paragraph">
<p>Other states memorize the length of block separator line to find the matching closing separator.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">Qualifying matches, push back and state change</dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>After a match the Java code checks additional conditions like if this is an unconstrained position in the stream.
If the code decides to discard the match, two possible strategies out of several are:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Push back all but the first character, and return the token type for the single character.
As an example, when a double-asterisk occurs, but no bold text is to end here, see <code>{DOUBLEMONO}</code> in the lexer.</p>
</li>
<li>
<p>Push back the complete text and continue with a different state using <code>yybegin()</code> (for example when matching a <code>{HEADING_OLDSTYLE}</code> in the <code>MULTILINE</code> state).</p>
</li>
<li>
<p>Some expressions can be prefixed with a backslash (<code>\</code>) to escape the expression.
Use <code>isEscaped()</code> to check if it has been escaped.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Unfortunately, the parser can&#8217;t continue with other matches in the same state.
To work around this issue, blocks are parsed first in state <code>MULTILINE</code>, then in state <code>SINGLELINE</code>, and finally <code>INSIDE_LINE</code> to implement a hierarchy and some ordering of matches.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">Auto-completion</dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Expressions described above match expressions once they have their closing syntax completed, and it is essential for the correct highlighting.
To support autocomplete the matching must handle an expression where only the left part of the expression exists.</p>
</div>
<div class="paragraph">
<p>A special case is in the parser to support autocompletion, as IntelliJ inserts a special string when parsing the content for autocompletion (named <code>auto-complete</code> in our parser).</p>
</div>
<div class="paragraph">
<p>In the case for references (<code>&lt;&lt;ref&gt;&gt;</code>) there are two rules, one for regular parsing and highlighting, one without:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>// regular
{REFSTART} / [^&gt;\n]+ {REFEND} { yybegin(REF); return AsciiDocTokenTypes.REFSTART; }
// auto-complete
{REFSTART} / [^&gt;\n ]* {AUTOCOMPLETE} { yybegin(REFAUTO); return AsciiDocTokenTypes.REFSTART; }</code></pre>
</div>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="highlighting"><a class="anchor" href="#highlighting"></a>Highlighting</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Highlighting is coloring the text in the editor.</p>
</div>
<div class="paragraph">
<p>The file <code>AsciiDocSyntaxHighlighter</code> defines one <code>TextAttributesKey</code> to each entry in <code>AsciiDocTokenTypes</code> parsed during lexing.
Currently, several tokens have the same highlighting <code>ASCIIDOC_MARKER</code>, so users have the same color for the pointy brackets around references (<code>&lt;&lt;ref&gt;&gt;</code>)and markers for bold (<code>*bold*</code>).</p>
</div>
<div class="paragraph">
<p>Once you add a new <code>TextAttributesKey</code>, you should either:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>reference an existing color (like <code>ASCIIDOC_COMMENT</code> references <code>DefaultLanguageHighlighterColors.LINE_COMMENT</code>) OR</p>
</li>
<li>
<p>add a color the AsciiDoc themes <code>AsciidocDefault.xml</code> and <code>AsciidocDarcula.xml</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Once you add a new token, you will need to add it to <code>AsciiDocColorSettingsPage</code> so users can customize the colors of their theme.
This class references also <code>SampleDocument.adoc</code> and <code>AsciiDocBundle.properties</code>, therefore you&#8217;ll probably need to change these two files as well.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="parsing"><a class="anchor" href="#parsing"></a>Parsing</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="why"><a class="anchor" href="#why"></a>Why</h3>
<div class="paragraph">
<p>Parsing gives a hierarchical structure and meaning to the tokens created in the parsing phase.</p>
</div>
<div class="paragraph">
<p>It can define <code>PsiElements</code> inside the tree to allow interactions with the user like renaming of elements and autocompletion.
The structure is the foundation of the structure outline view and the folding capabilities.</p>
</div>
</div>
<div class="sect2">
<h3 id="how"><a class="anchor" href="#how"></a>How</h3>
<div class="paragraph">
<p>The <code>AsciiDocParserDefinition</code> separates spaces and comments from functional tokens.
It also serves as a factory for all <code>PsiElement</code>s like <code>AsciiDocSection</code> for sections and <code>AsciiDocBlock</code> for blocks.</p>
</div>
<div class="paragraph">
<p><code>AsciiDocParserImpl</code> encodes the logic how to group the tokens to a tree.
To do this, it has several strategies.
This outline summarizes the most distinct strategies:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">References</dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Once it sees the start token <code>REFSTART</code> (usually two opening pointy brackets, like <code>&lt;&lt;</code>), it sets a marker.
Then it reads all tokens that are valid inside a reference.
Once there are no more valid tokens for a reference, it marks this block as a <code>AsciiDocElementTypes.REF</code>.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">Blocks</dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>A block starts, for example, with a <code>LISTING_BLOCK_DELIMITER</code> (usually four dashes in a line, like <code>----</code>).
Then the block continues up to the point where the same marker occurs again.</p>
</div>
<div class="paragraph">
<p>But the block can be preceded, for example, by a title (it starts with a dot, following by the title itself, like <code>.Title</code>).
This title is part of the block.
To support this <code>TITLE</code> and several other elements call <code>markPreBlock()</code> to memorize the first token that is part of a following block.
It is stored in a variable <code>myPreBlockMarker</code>.</p>
</div>
<div class="paragraph">
<p>When parsing of the block starts and the <code>myPreBlockMarker</code> is set, it uses this marker.
If the marker is not set, is creates a new marker at the start of the block delimiter.
When the block doesn&#8217;t start on one of the following lines, <code>dropPreBlock()</code> drops the marker.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">Sections</dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Sections build on top of blocks.
They can have pre-block elements as well.</p>
</div>
<div class="paragraph">
<p>In addition to standard blocks, they build a hierarchy:
Each section has a level determined by the number of equal signs at the start (or, if it is an old style heading by the character underlining the heading).</p>
</div>
<div class="paragraph">
<p>Whenever a section with the same level as the one before starts, the previous section needs to be closed.
Whenever a section of a higher order starts (let&#8217;s assume two equal signs at the start, like <code>==</code>), all open sections with a lower order must be closed (in this case with three or more equal signs at the start).
This logic is encapsulated in <code>closeSections()</code>.
It is also called at the end of the document to close all sections at the end of the document.</p>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="debugging"><a class="anchor" href="#debugging"></a>Debugging</h3>
<div class="paragraph">
<p>To analyze the structure interactively, install the PsiViewer plugin.
The plugin is pre-installed in the sandbox IDE you start using the <code>runIde</code> Gradle ask.</p>
</div>
<div class="paragraph">
<p>You can also install it in the IDE you develop in, but this is optional.</p>
</div>
<div class="paragraph">
<p>Right-click on the AsciiDoc editor and choose <span class="menuseq"><b class="menu">PsiViewer</b>&#160;<i class="fa fa-angle-right caret"></i> <b class="menuitem">View PSI for entire file</b></span> to browse the tree.
There is also a keyboard shortcut for this.</p>
</div>
</div>
<div class="sect2">
<h3 id="testing"><a class="anchor" href="#testing"></a>Testing</h3>
<div class="paragraph">
<p>There are unit tests for the parser.
You can run them from your IDE.
The tests come in two variants:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">AsciiDocPsiTest</dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>This test parses a minimal snippet of AsciiDoc, creates the PSI tree, and the lets you apply assertions like in normal unit tests.</p>
</div>
<div class="paragraph">
<p>Use this to write specific tests.
Consider a given/when/then structure to write tests that are comprehensible for other developers.
As you test only specific elements in the created tree, your tests will not break when parts of the tree change that are irrelevant to the tested functionality.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">AsciiDocParserTest</dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>This test acts on example files in <code>/testData/parser</code> together with a known good file.</p>
</div>
<div class="paragraph">
<p>To write a new test, create a new method in the class (like <code>testSectionsWithPreBlock()</code>).
Then put a matching AsciiDoc file to the example file directory (like <code>sectionsWithPreBlock.adoc</code>).
When you run the test for the first time, it will create a known good file (like <code>sectionsWithPreBlock.txt</code>).
Check the contents of the known good file if the result matches your expectations.</p>
</div>
<div class="paragraph">
<p>On consecutive runs the test will compare the parser result with the contents of the known good file.
If the content matches, the test will pass.
If there are differences, the test will fail.
If you expected these differences, for example, because you changed the parser or lexer, copy the result shown in your IDE to the known good file.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please check in the known good file to the Git repository!
</td>
</tr>
</table>
</div>
</div>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>So why are there two types of tests?
Each has its own strengths!</p>
</div>
<div class="paragraph">
<p>The known good approach will trigger even on minor changes to the output and gives you the chance to approve or reject the changes.
The downside is that these tests will fail when there are unrelated changes because they check too many things.
For a known good test, it is also hard to see the parts of the known good that are relevant for the expected behavior and must not change.</p>
</div>
<div class="paragraph">
<p>The test with single assertions will be most specific to the described functionality, and will leave out parts that are unrelated to the test.
Therefore, it will not break for unrelated changes.
Meaningful assertions allow fellow developers to understand the expected functionality.
Writing such a test is often slower as it requires more code and skill, but it will pay off as it will break less often due to unrelated changes.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="interacting-with-psielements"><a class="anchor" href="#interacting-with-psielements"></a>Interacting with PsiElements</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="references-and-renaming"><a class="anchor" href="#references-and-renaming"></a>References and renaming</h3>
<div class="paragraph">
<p>All PsiElement that reference files (like for example an <code>include::[]</code>) or IDs (like for example <code>&lt;&lt;id&gt;&gt;</code>) return references.
Examples for this are <code>AsciiDocBlockMacro</code> and <code>AsciiDocRef</code>.
They all need to provide a <code>Manipulator</code> that IntelliJ calls when the user renames such a reference.
To make the &#8220;Find References&#8221; functionality work, the tokens that contain the IDs need to be part of the Identifier-Token-Set in <code>AsciiDocWordsScanner</code>.</p>
</div>
<div class="paragraph">
<p>TODO: refactoring, folding, autocompletion</p>
</div>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="debugging-and-logging.html">Debugging and Logging</a></span>
  <span class="next"><a href="inspections.html">Inspections</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
    <p>This page was built using <a href="https://antora.org/" rel="nofollow">Antora</a> - © 2013-2021 Julien Viet, Erik Pragt, Alexander Schwartz and the individual contributors. Released under the Apache License, Version 2.0 - <a href="https://github.com/asciidoctor/asciidoctor-intellij-plugin" rel="nofollow">GitHub</a> - <a href="/imprint" rel="nofollow">Imprint</a> - <a href="/privacy" rel="nofollow">Privacy</a></p>
</footer>
<div id="myModal" class="modal">
    <span class="close cursor" onclick="closeModal()">&times;</span>
    <div class="modal-content" onclick="closeModal()">
        <!--suppress HtmlRequiredAltAttribute as this will be set when selecting the image via JavaScript,
        RequiredAttributes as src will be set by when selecting the image via JavaScript -->
        <img id="imageinmodal">
    </div>
</div>
<script>
    function openModal() {
        document.getElementById("myModal").style.display = "block";
        // use overflowY = hidden to prevent the body from scrolling when modal is visible
        // doesn't work with overscroll-behavior, as this would work only when the modal has a scrollbar
        document.getElementsByTagName("body")[0].style.overflowY = "hidden";
    }

    function closeModal() {
        document.getElementById("myModal").style.display = "none";
        document.getElementsByTagName("body")[0].style.overflowY = "auto";
    }

    document.querySelectorAll('.imageblock img').forEach(element => {
        if (element.closest('a') === null) {
            element.className += " lightbox";
            element.addEventListener('click', evt => {
                document.getElementById("imageinmodal").setAttribute("src", evt.currentTarget.getAttribute("src"))
                document.getElementById("imageinmodal").setAttribute("alt", evt.currentTarget.getAttribute("alt"))
                openModal();
            })
        }
    });
</script>
<style>
    /* The Modal (background) */
    .modal {
        display: none;
        position: fixed;
        z-index: 10;
        padding-top: 5vh;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        backdrop-filter: blur(3px);
        background-color: rgba(30, 30, 30, 0.8);
    }
    img.lightbox {
        cursor: pointer;
    }
    /* Modal Content */
    .modal-content {
        position: relative;
        margin: auto;
        padding: 0;
        width: 90%;
        max-height: 90vh;
        cursor: pointer;
    }

    .modal-content img {
        width: auto;
        height: auto;
        max-width: 90vw;
        max-height: 90vh;
        min-width: 90vw;
        min-height: 90vh;
        display: block;
        margin-right: auto;
        margin-left: auto;
        object-fit: contain;
    }

    /* The Close Button */
    .close {
        color: white;
        position: absolute;
        top: 10px;
        right: 25px;
        font-size: 35px;
        font-weight: bold;
    }

    .close:hover,
    .close:focus {
        color: #999;
        text-decoration: none;
        cursor: pointer;
    }
</style>
<script src="../../antora/js/os-switcher.js"></script>
<script>
    const navbarEl = document.getElementsByClassName("navbar")[0]
    const toolbarEl = document.getElementsByClassName("toolbar")[0]
    let NAVBAR_HEIGHT
    let horizon
    let scrollFactor = 0
    let whereYouStoppedScrolling = 0
    let currentTranslate = 0
    let currentStyle = ""

    function upOrDown(lastY, currentY) {
        if (currentY >= lastY) {
            return goingDown(currentY)
        }
        return goingUp(currentY)
    }

    function goingDown(currentY) {
        whereYouStoppedScrolling = currentY

        if (currentY > horizon) {
            horizon = currentY
        }

        translateHeader(currentY, false)
    }

    function goingUp(currentY) {
        if (currentY < whereYouStoppedScrolling - NAVBAR_HEIGHT) {
            horizon = currentY + NAVBAR_HEIGHT
        }

        translateHeader(currentY, true)
    }

    function constrainDelta(delta) {
        return Math.max(0, Math.min(delta, NAVBAR_HEIGHT))
    }

    function translateHeader(currentY, upwards) {
        let translateValue

        // if I have scrolled down sufficiently, the navbar appears faster
        if (currentY > NAVBAR_HEIGHT * 2) {
            scrollFactor = 1
        } else if (currentY > NAVBAR_HEIGHT) {
            scrollFactor = (currentY - NAVBAR_HEIGHT) / NAVBAR_HEIGHT
        } else {
            scrollFactor = 0
        }

        if (upwards && currentTranslate === 0) {
            translateValue = 0
        } else {
            const delta = constrainDelta(
                    Math.abs(currentY - horizon) * (1 + scrollFactor)
            )
            translateValue = delta - NAVBAR_HEIGHT
        }

        if (window.innerWidth > 1024) {
            translateValue = 0
        } else if (document.getElementsByClassName("nav-container")[0].classList.contains("is-active")) {
            translateValue = 0
        }

        if (!isNaN(translateValue)) {
            let navbarStyle = `transition: transform 0.5s ease-out; transform: translateY(${translateValue}px);`
            if (translateValue === -NAVBAR_HEIGHT) {
                navbarStyle = `transition: transform 0.5s ease-out; transform: translateY(${translateValue}px);`
            }
            if (currentY <= NAVBAR_HEIGHT) {
                navbarStyle = `transform: translateY(${translateValue}px);`
            }
            currentTranslate = translateValue
            if (currentStyle !== navbarStyle) {
                currentStyle = navbarStyle
                navbarEl.setAttribute("style", navbarStyle)
                toolbarEl.setAttribute("style", navbarStyle)
            }
        }
    }

    translateHeader(window.scrollY, false)

    let ticking = false
    let lastY = 0

    window.addEventListener("scroll", function () {
        if (NAVBAR_HEIGHT === undefined) {
            // lazy initialization on first scroll
            NAVBAR_HEIGHT =
                    parseInt(window.getComputedStyle(navbarEl).height.replace("px", "")) +
                    1
            horizon = NAVBAR_HEIGHT
        }
        const currentY = window.scrollY

        if (!ticking && window.requestAnimationFrame) {
            window.requestAnimationFrame(function () {
                upOrDown(lastY, currentY)
                ticking = false
                lastY = currentY
            })
        }

        ticking = true
    })

    window.addEventListener('resize', function () {
        NAVBAR_HEIGHT = undefined
        const currentY = 0
        upOrDown(lastY, currentY)
        lastY = currentY
        return true
    })


    document.getElementsByClassName("nav-toggle")[0].addEventListener("click", function () {
        const currentY = 0
        upOrDown(lastY, currentY)
        lastY = currentY
        return true
    })

</script>
<script>
  window.antora = window.antora || {}
  window.antora.basePath = '../..'
  window.antora.pagePath = '/contributors-guide/coder/lexing-and-parsing.html'
</script>
<script src="../../antora/js/site.js"></script>
<script src="../../antora/js/vendor/lunr.js"></script>
<script src="../../antora/js/search-ui.js" id="search-ui-script" data-site-root-path="../.." data-snippet-length="100" data-stylesheet="../../antora/css/search.css"></script>
<script async src="../../search-index.js"></script>
  </body>
</html>
